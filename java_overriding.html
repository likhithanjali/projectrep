<!DOCTYPE html>
<html>
<head>
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
<style>
body {
  margin: 0;
  font-family: Arial, Helvetica, sans-serif;
}
.topnav {
  overflow: hidden;
  background-color: #f2f2f2;
}
.topnav a {
  float: left;
  color: #000080;
  text-align: center;
  padding: 14px 16px;
  text-decoration: none;
  font-size:20px;
}

.topnav a:hover {
  background-color: #ddd ;
  color: black;
}

.topnav a.active {
  background-color:#000080  ;
  color:white;
}

header, footer {
    padding: 1em;
    color: white;
    background-color: #000080;
    clear: left;
    font-size:large;
    text-align: center;
}

nav {
    float: left;
    max-width: 180px;
    margin: 0;
    padding: 1em;
}

nav ul {
    list-style-type: none;
    padding: 0;
    font-size:20px;
}

nav ul a {
    text-decoration: none;
}

article {
    margin-left: 170px;
    border-left: 1px solid gray;
    padding: 1em;
    overflow: hidden;
} 
.icon-bar a {
    float: left;
    width: 5%;
    text-align: center;
    padding: 13px 0;
    color: #000080;
    font-size: 25px;
}
.vertical-menu {
    width: 180px;
}

.vertical-menu a {
    background-color:#eee;
    color:black;
    display: block;
    padding:15px;
    text-decoration: none;
}

.vertical-menu a:hover {
    background-color: #ccc;
}

.vertical-menu a.active {
    background-color: #000080;
    color: white;
}
a{
    text-decoration: none;
    display: inline-block;
    padding: 9px 17px;
}

a:hover {
    background-color: #ddd;
    color: black;
}

.previous {
    background-color:#000080;
    color: white;
}

.next {
    background-color: #000080;
    color: white;
	margin-left:780px;
}

</style>

</head>
<body>
<header>
<h1>JAVA</h1>
</header>

<div class="topnav">
  <div class="icon-bar"> <a class="" href="index.html"><i class="fa fa-home"></i></a> </div>
<a href="allprolang.html">All Languages</a>
  <a href="c_overview.html">C</a>
  <a href="cpp_overview.html">CPP</a>
  <a class="active" href="java_overview.html">JAVA</a>
  <a href="html_overview.html">HTML</a>
  <a href="css_overview.html">CSS</a>
  <a href="javascript_overview.html">JAVASCRIPT</a>
  <a href="python_overview.html">PYTHON</a>
   
  <div class="icon-bar"> <a class="" href="#"><i class="fa fa-search"></i></a> </div></div>
<nav>
<div class="vertical-menu">
<a href="java_overview.html">Overview</a>
<a href="java_environmentalsetup.html">Environment Setup</a>
<a href="java_basicsyntax.html">Basic Syntax</a>
<a href="java_comments.html">Comments</a>
<a href="java_obj&cls.html">Objects&Classes</a>
<a href="java_datatypes.html">Data Types</a>
<a href="java_variables.html">Variable Types</a>
<a href="java_modifiertypes.html">Modifier Types</a>
<a href="java_operators.html">Basic Operators</a>
<a href="java_loops.html">Loops</a>
<a href="java_decisionmake.html">Decision Making</a>
<a href="java_characters.html">Characters</a>
<a href="java_strings.html">strings</a>
<a href="java_arrays.html">Arrays</a>
<a href="java_datetime.html">Date&Time</a>
<a href="java_regularexpr.html">Regular expressions</a>
<a href="java_methods.html">Methods</a>
<a href="java_io.html">Files and i/o</a>
<a href="java_excepetions.html">Exceptions </a>
<a href="java_innerclass.html">Inner classes</a>
<a href="java_inheritance.html">Inheritance </a>
<a href="java_overriding.html">Overrding</a>
<a href="java_overloading.html">Overloading</a>
<a href="java_polymorphism.html">Polymorphism</a> 
<a href="java_Abstraction.html">Abstraction</a>
<a href="java_encapsulation.html">Encapsulation</a>
<a href="java_interfaces.html">Interfaces</a>
<a href="java_packages.html">Packages</a>
</div> </nav>

<article>
<a href="java_inheritance.html" class="previous">&laquo; Previous</a>
<a href="java_overloading.html" class="next">Next &raquo;</a>
<h1 style="color:#000080">Overriding In Java</h1>

<p>Declaring a method in sub class which is already present in parent class is known as method overriding. Overriding is done so that a child class can give its own implementation to a method which is already provided by the parent class. In this case the method in parent class is called overridden method and the method in child class is called overriding method. In this guide, we will see what is method overriding in Java and why we use it.</p>

<h4>Method Overriding Example</h4>
<p>Lets take a simple example to understand this. We have two classes: A child class Boy and a parent class Human. The Boy class extends Human class. Both the classes have a common method void eat(). Boy class is giving its own implementation to the eat() method or in other words it is overriding the eat() method.<br>

The purpose of Method Overriding is clear here. Child class wants to give its own implementation so that when it calls this method, it prints Boy is eating instead of Human is eating.</p>
<table border="" height="" width="500"><tr><td><pre>
class Human{
   //Overridden method
   public void eat()
   {
      System.out.println("Human is eating");
   }
}
class Boy extends Human{
   //Overriding method
   public void eat(){
      System.out.println("Boy is eating");
   }
   public static void main( String args[]) {
      Boy obj = new Boy();
      //This will call the child class version of eat()
      obj.eat();
   }
}
<pre></td></tr></table>
<h4>Output:</h4>
<table border="" height="" width="500"><tr><td>
Boy is eating
</td></tr></table>
<h3>Advantage of method overriding</h4>
<p>The main advantage of method overriding is that the class can give its own specific implementation to a inherited method without even modifying the parent class code.<br>

This is helpful when a class has several child classes, so if a child class needs to use the parent class method, it can use it and the other classes that want to have different implementation can use overriding feature to make changes without touching the parent class code.</p>

<h3>Method Overriding and Dynamic Method Dispatch</h3>
<p>Method Overriding is an example of runtime polymorphism. When a parent class reference points to the child class object then the call to the overridden method is determined at runtime, because during method call which method(parent class or child class) is to be executed is determined by the type of object. This process in which call to the overridden method is resolved at runtime is known as dynamic method dispatch. Lets see an example to understand this:</p>
<table border="" height="" width="500"><tr><td><pre>
class ABC{
   //Overridden method
   public void disp()
   {
	System.out.println("disp() method of parent class");
   }	   
}
class Demo extends ABC{
   //Overriding method
   public void disp(){
	System.out.println("disp() method of Child class");
   }
   public void newMethod(){
	System.out.println("new method of child class");
   }
   public static void main( String args[]) {
	/* When Parent class reference refers to the parent class object
	 * then in this case overridden method (the method of parent class)
	 *  is called.
	 */
	ABC obj = new ABC();
	obj.disp();

	/* When parent class reference refers to the child class object
	 * then the overriding method (method of child class) is called.
	 * This is called dynamic method dispatch and runtime polymorphism
	 */
	ABC obj2 = new Demo();
	obj2.disp();
   }
}
</pre></td></tr></table>
<h4>Output:</h4>
<table border="" height="" width="500"><tr><td>
disp() method of parent class<br>
disp() method of Child class
</td></tr></table>
<p>In the above example the call to the disp() method using second object (obj2) is runtime polymorphism (or dynamic method dispatch).<br>
<b>Note:</b> In dynamic method dispatch the object can call the overriding methods of child class and all the non-overridden methods of base class but it cannot call the methods which are newly declared in the child class. In the above example the object obj2 is calling the disp(). However if you try to call the newMethod() method (which has been newly declared in Demo class) using obj2 then you would give compilation error with the following message:</p>
<table border="" height="" width="500"><tr><td><br>
Exception in thread "main" java.lang.Error: Unresolved compilation 
problem: The method xyz() is undefined for the type ABC
</td></tr></table>
<h3>Rules of method overriding in Java</h3>
<p><b>1.Argument list:</b> The argument list of overriding method (method of child class) must match the Overridden method(the method of parent class). The data types of the arguments and their sequence should exactly match.<br>
2.Access Modifier of the overriding method (method of subclass) cannot be more restrictive than the overridden method of parent class. For e.g. if the Access Modifier of parent class method is public then the overriding method (child class method ) cannot have private, protected and default Access modifier,because all of these three access modifiers are more restrictive than public.<br>
For e.g. This is not allowed as child class disp method is more restrictive(protected) than base class(public)</p>
<table border="" height="" width="500"><tr><td><pre>
class MyBaseClass{
   public void disp()
   {
       System.out.println("Parent class method");
   }
}
class MyChildClass extends MyBaseClass{
   protected void disp(){
      System.out.println("Child class method");
   }
   public static void main( String args[]) {
      MyChildClass obj = new MyChildClass();
      obj.disp();
   }
}
</pre></td></tr></table>
<h4>Output:</h4>
<table border="" height="" width="500"><tr><td>
Exception in thread "main" java.lang.Error: Unresolved compilation<br> 
problem: Cannot reduce the visibility of the inherited method from MyBaseClass
</tr></td></table>
<p>However this is perfectly valid scenario as public is less restrictive than protected. Same access modifier is also a valid one.</p>
<table border="" height="" width="500"><tr><td><pre>
class MyBaseClass{
   protected void disp()
   {
       System.out.println("Parent class method");
   }
}
class MyChildClass extends MyBaseClass{
   public void disp(){
      System.out.println("Child class method");
   }
   public static void main( String args[]) {
      MyChildClass obj = new MyChildClass();
      obj.disp();
   }
}
</pre></td></tr></table>
<h4>Output:</h4>
<table border="" height="" width="500"><tr><td>
Child class method
</tr></td></table>
<p>3.private, static and final methods cannot be overridden as they are local to the class. However static methods can be re-declared in the sub class, in this case the sub-class method would act differently and will have nothing to do with the same static method of parent class.<br>
4.Overriding method (method of child class) can throw unchecked exceptions, regardless of whether the overridden method(method of parent class) throws any exception or not. However the overriding method should not throw checked exceptions that are new or broader than the ones declared by the overridden method.<br> 
5.Binding of overridden methods happen at runtime which is known as dynamic binding.<br>
6.If a class is extending an abstract class or implementing an interface then it has to override all the abstract methods unless the class itself is a abstract class.<p>
<h3>Super keyword in Method Overriding</h3>
<p>The super keyword is used for calling the parent class method/constructor. super.myMethod() calls the myMethod() method of base class while super() calls the constructor of base class. Let’s see the use of super in method Overriding.</br>
As we know that we we override a method in child class, then call to the method using child class object calls the overridden method. By using super we can call the overridden method as shown in the example below:</p>
<table border="" height="" width="500"><tr><td><pre>
class ABC{
   public void myMethod()
   {
	System.out.println("Overridden method");
   }	   
}
class Demo extends ABC{
   public void myMethod(){
	//This will call the myMethod() of parent class
	super.myMethod();
	System.out.println("Overriding method");
   }
   public static void main( String args[]) {
	Demo obj = new Demo();
	obj.myMethod();
   }
}
</pre></td></tr></table>
<h4>Output:</h4>
<table border="" height="" width="500"><tr><td>
Class ABC: mymethod()
Class Test: mymethod()
</td></tr></table>
<br><br>
<a href="java_inheritance.html" class="previous">&laquo; Previous</a>
<a href="java_overloading.html" class="next">Next &raquo;</a>
</article>
<footer>Devoloped by LE's</footer>
</body>
</html>